<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Swerve Drive Implementation & Commands</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="stylesheet" href="styles.css">
</head>
<body>

<header class="site-header">
    <a href="index.html" class="site-logo">
        <div class="logo-circle">86</div>
        <div class="logo-text">
            <span class="team-name">Programming Training</span>
            <span class="team-tagline">Going against the current</span>
        </div>
    </a>

    <button class="mobile-menu-toggle" onclick="toggleMobileMenu()">☰</button>
</header>

<nav class="sidebar-nav" id="sidebarNav">
    <div class="nav-section">
        <a href="index.html">Home</a>
        <br>

        <div class="nav-section-title">Quick Reference</div>
        <ul>
            <li><a href="pid-tuning.html">Tuning PID</a></li>
            <li><a href="abstract-io.html">Subsystem IO Abstraction</a></li>
            <li><a href="pathfinding.html">Pathing</a></li>
            <li><a href="standards.html">Code Standards</a></li>
            <li><a href="swerve.html">Swerve Drive</a></li>
        </ul>
    </div>

    <div class="nav-section">
        <div class="nav-section-title">External</div>
        <ul>
            <li><a href="https://docs.wpilib.org/" target="_blank">WPILib Docs ↗</a></li>
            <li><a href="https://www.thebluealliance.com/" target="_blank">The Blue Alliance ↗</a></li>
            <li><a href="https://docs.advantagekit.org/" target="_blank">AdvantageKit ↗</a></li>
        </ul>
    </div>
</nav>

<main class="main-content">
    <div class="content-wrapper">
        <h1>⚙️ Swerve Drive Implementation &amp; Commands</h1>
        <p>Swerve code can be intimidating - this document details the software architecture for the swerve drive, including constants, the primary subsystem logic, and essential commands for teleoperated driving, path following, and characterization.</p>

        <section>
            <h2>Configuration: The <code>TunerConstants</code> Class</h2>
            <p>The <code>TunerConstants</code> class serves as the constants file for all physical and control parameters of the swerve drivetrain. These values are crucial for accurate motion. The TunerConstants file is also generated by CTRE's Phoenix Tuner - none of this is written manually.</p>
            <ul>
                <li>Kinematic Parameters: Defines the physical layout and gearing, including the wheel radius (<code>kWheelRadius</code>), drive base size (module locations like <code>kFrontLeftXPos</code>), and gear ratios (<code>kDriveGearRatio</code>, <code>kSteerGearRatio</code>).</li>
                <li>PID Gains: Separate <code>Slot0Configs</code> are defined for both the Steer and Drive motors, including Proportional (<code>KP</code>), Integral (<code>KI</code>), Derivative (<code>KD</code>), Static Feedforward (<code>KS</code>), and Velocity Feedforward (<code>KV</code>). These must be tuned to prevent the robot from being jerky, too slow, accelerating too fast, and numerous other small issues.
                <li>Steer Gains Example: The steering motor uses a high <code>KP</code> (50) and a small <code>KD</code> (0.5) to rapidly accelerate to the requested position.</li>
                </li>
                <li>Motor/Sensor IDs: Specifies the CAN IDs for all TalonFX drive motors, TalonFX steer motors, and CANcoder absolute encoders for each of the four modules.</li>
                <li>Physical Constraints: Includes the theoretical maximum speed (<code>kSpeedAt12Volts</code>) and the current limit at which wheels are expected to slip (<code>kSlipCurrent</code>).</li>
            </ul>
        </section>

        <hr>

        <section>
            <h2>Subsystem Logic: The <code>SwerveDriveSubsystem</code></h2>
            <p>The swerve drive subsystem is implemented using the AdvantageKit abstraction, relying on the <code>SwerveDriveIO</code> interface. It integrates hardware control, odometry, and pathfinding setup. Refer to <a href="abstract-io.html">Subsystem IO Abstraction</a> if you forgot how it works!</p>
            
            <h3>Odometry and Pose Estimation</h3>
            <p>The subsystem maintains the robot's field position using a SwerveDrivePoseEstimator. </p>
            <ul>
                <li>Core Data: It fuses data from the Gyro (<code>rawGyroRotation</code>) and the positions of all four Swerve Modules (<code>lastModulePositions</code>).</li>
                <li>Update Loop: The <code>periodic()</code> method is responsible for continuously updating the pose estimator with time-stamped data from the gyroscope and modules.</li>
                <li>Vision Integration: The methods <code>addVisionMeasurement()</code> and <code>addAutoVisionMeasurement()</code> allow external vision systems (like Limelight or PhotonVision) to correct the estimated pose, improving accuracy by miles - relying on odometry alone is bound to fail as the wheels can slip frequently. <a href="https://v6.docs.ctr-electronics.com/en/latest/docs/application-notes/update-frequency-impact.html">See this</a> for more unneccessary - but cool to know - odometry info</li>
            </ul>

            <h3>PathPlanner Setup</h3>
            <p>The subsystem configures the PathPlanner <code>AutoBuilder</code> to enable autonomous routines. This includes defining:</p>
            <ul>
                <li>State Getters/Setters: Methods like <code>getPose()</code>, <code>setPose()</code>, <code>getChassisSpeeds()</code>.</li>
                <li>Drive Command: The <code>runVelocity()</code> method is used to execute the calculated path speeds.</li>
                <li>Control Parameters: Holonomic PID controllers (PPHolonomicDriveController) for both the X/Y translation and the rotation are configured.</li>
                <li>Pathfinding: It uses the <code>LocalADStarAK</code> implementation for real-time obstacle avoidance and dynamic path generation.</li>
            </ul>
        </section>

        <hr>

        <section>
            <h2>Commands: The <code>DriveCommands</code> Utility Class</h2>
            <p>This class contains static factory methods for generating reusable drive commands.</p>

            <h3>Teleoperated Driving Commands</h3>
            
            <h4><code>joystickDrive(...)</code></h4>
            <p>This is the standard, field-relative drive command. It maps raw joystick inputs (X, Y, and Omega) to robot speeds.</p>
            <ul>
                <li>Input Mapping: It applies a deadband (<code>DEADBAND = 0.1</code>) to the joystick inputs to prevent unintentional drift. It then squares the magnitude (<code>linearMagnitude * linearMagnitude</code>) and rotation (<code>omega * omega</code>) for finer low-speed control.</li>
                <li>Field-Relative Control: It converts the joystick-derived <code>ChassisSpeeds</code> from robot-relative to field-relative using the current Gyro rotation (<code>drive.getRotation()</code>).</li>
                <li>Alliance Flipping: It automatically flips the drive direction (adds 180° to what angle the robot thinks it is looking) if the robot is on the Red Alliance, ensuring the controls are always relative to the driver's perspective.</li>
            </ul>

            <h4><code>joystickDriveAtAngle(...)</code></h4>
            <p>A specialized command for driving while maintaining or targeting a specific field-relative rotation. You can use this if you want the robot to aim at a target while moving, for example, if it was a shooter game.</p>
            <ul>
                <li>Linear Control: Linear motion (X and Y) is still controlled by the raw joystick input.</li>
                <li>Angular Control: Angular velocity is controlled by a Profiled PID Controller (<code>angleController</code>). This controller calculates the necessary value to move the current robot angle (<code>drive.getRotation()</code>) toward the supplier-provided target angle (<code>rotationSupplier.get()</code>) using a motion profile.</li>
            </ul>

            <h3>Path Following and Navigation Commands</h3>

            <h4><code>goToTransform(...)</code></h4>
            <p>A command that uses separate Profiled PID Controllers for the X, Y, and rotation axes to drive the robot to a target <code>Pose2d</code> (derived from a <code>Transform2d</code>) in a straight line, without using pathfinding.</p>
            <ul>
                <li>Axis Control: Three PID controllers are used: <code>pidX</code>, <code>pidY</code>, and <code>angleController</code>.</li>
                <li>Stopping Condition: The command terminates (<code>.until(...)</code>) when the robot is within a small positional tolerance (0.07 meters in X and Y) and angular tolerance (5 degrees) of the target.</li>
            </ul>

            <h4><code>followCurve(...)</code> and <code>followPoses(...)</code></h4>
            <p>These commands utilize the PathPlanner library to generate and follow complex paths.</p>
            <ul>
                <li>Path Generation: The logic first converts the provided control points (<code>followCurve</code>) or poses (<code>followPoses</code>) into a PathPlanner <code>PathPlannerPath</code> object, which includes motion constraints.</li>
                <li>Sequence: The final command is a sequence: first, it uses <code>AutoBuilder.pathfindToPose</code> to navigate dynamically from the current location to the path's start point; second, it uses <code>AutoBuilder.followPath</code> to precisely follow the pre-generated curve or pose path.</li>
            </ul>
        </section>

        </div>
</main>

<footer class="site-footer">
    <p>Team Resistance - Going against the current</p>
</footer>

<script>
    function toggleMobileMenu() {
        const sidebar = document.getElementById('sidebarNav');
        sidebar.classList.toggle('active');
    }

    document.addEventListener('click', function(event) {
        const sidebar = document.getElementById('sidebarNav');
        const toggle = document.querySelector('.mobile-menu-toggle');

        if (window.innerWidth <= 1024 &&
            !sidebar.contains(event.target) &&
            !toggle.contains(event.target) &&
            sidebar.classList.contains('active')) {
            sidebar.classList.remove('active');
        }
    });
</script>
</body>
</html>