<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pathfinding & PathPlanner</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="stylesheet" href="styles.css">
</head>
<body>

<!-- Header -->
<header class="site-header">
    <a href="index.html" class="site-logo">
        <div class="logo-circle">86</div>
        <div class="logo-text">
            <span class="team-name">Programming Training</span>
            <span class="team-tagline">Going against the current</span>
        </div>
    </a>

    <button class="mobile-menu-toggle" onclick="toggleMobileMenu()">☰</button>
</header>

<!-- Sidebar -->
<nav class="sidebar-nav" id="sidebarNav">
    <div class="nav-section">
        <a href="index.html">Home</a>
        <br>

        <div class="nav-section-title">Quick Reference</div>
        <ul>
            <li><a href="pid-tuning.html">Tuning PID</a></li>
            <li><a href="abstract-io.html">Subsystem IO Abstraction</a></li>
            <li><a href="pathfinding.html">Pathing</a></li>
            <li><a href="standards.html">Code Standards</a></li>
            <li><a href="swerve.html">Swerve Drive</a></li>
        </ul>
    </div>

    <div class="nav-section">
        <div class="nav-section-title">External</div>
        <ul>
            <li><a href="https://docs.wpilib.org" target="_blank">WPILib Docs ↗</a></li>
            <li><a href="https://www.thebluealliance.com" target="_blank">The Blue Alliance ↗</a></li>
            <li><a href="https://docs.advantagekit.org/" target="_blank">AdvantageKit ↗</a></li>
        </ul>
    </div>
</nav>

<!-- Main Content -->
<main class="main-content">
    <div class="content-wrapper">
        <!-- Page-specific content starts here -->
        <h1>Pathfinding & PathPlanner</h1>
        <p>
            Sometimes, it is worth it to pre-plan paths for robot movement and actions instead of doing it on the fly.
            This page covers PathPlanner, a tool to do so.
        </p>

        <section>
            <h3>What is Path Planning?</h3>
            <p>
                Path planning produces time-parameterized sequences of poses (x, y, rotation) plus velocities/accelerations.
                Benefits:
            </p>
            <ul>
                <li>Smooth, repeatable motion</li>
                <li>Velocity & acceleration constraints</li>
                <li>Event markers to trigger commands mid-path</li>
                <li>Easy visualization & editing via an editor</li>
            </ul>
        </section>

        <section>
            <h3>PathPlanner Overview</h3>
            <h4>Tool</h4>
            <p>
                PathPlanner (pathplanner.dev) is a GUI editor that exports path and autos into your robot project deploy folder:
            </p>

            <h4>Editor Features</h4>
            <ul>
                <li>Draw and edit waypoints</li>
                <li>Assign velocity/accel constraints</li>
                <li>Add event markers (strings) triggering commands</li>
                <li>Generate multi-path autos</li>
            </ul>
        </section>

        <section>
            <h3>Integrating PathPlanner with your Robot</h3>

            <h4>Dependencies</h4>
            <p>
                Add PathPlanner lib to your vendor dependencies through the vendor dependency manager.
            </p>

            <h4>Key Concepts</h4>
            <ul>
                <li><strong>Path</strong> - single trajectory file.</li>
                <li><strong>Auto</strong> - sequence of paths + events.</li>
				<li><strong>Named Command</strong> - how PathPlanner calls commands during an auto</li>
            </ul>
        </section>

            <h4>Load & Run a Path</h4>
            <pre><code class="language-java">
// This code goes in the RobotContainer - this is how you will typically create an auto selector.
  private LoggedDashboardChooser<Command> configureAutos() {

    // Set up auto routines
    LoggedDashboardChooser<Command> autoChooser =
        new LoggedDashboardChooser<>("Auto Choices", AutoBuilder.buildAutoChooser());

    return autoChooser;
  }
            </code></pre>
        </section>

        <section>
            <h3>Named Commands</h3>
            <p>
                Named commands are defined in-code and can be run by PathPlanner in an auto.
            </p>

            <h4>Example</h4>
            <pre><code class="language-java">
NamedCommands.registerCommand(
    "autoScore", new DeferredCommand(() -> new AutoScoreCommand(reef, drive, elevator)));
            </code></pre>
			<p>These commands run just the same as normal commands - but PathPlanner will wait to continue until they finish.</p>
        </section>

        <section>
            <h3>Making On-the-Fly / Teleop Paths</h3>
            <p>
                You can generate short paths at runtime (helpful for driver-assist or snapping to a scoring pose).
            </p>

            <h4>Simple runtime path from current pose → target pose</h4>
            <pre><code class="language-java">
public static Command followPoses(SwerveDriveIO drive, double transitionVelocity, Supplier<Pose2d[]> pointArraySupplier) {
    Pose2d[] points = pointArraySupplier.get();
    List<Waypoint> waypoints = PathPlannerPath.waypointsFromPoses(points);
    PathPlannerPath path =
        new PathPlannerPath(
            waypoints,
            Constants.PATH_CONSTRAINTS,
            new IdealStartingState(
                drive.getPose().getTranslation().getDistance(points[0].getTranslation()),
                points[0].getRotation()),
            new GoalEndState(0, points[points.length - 1].getRotation()));

    path.preventFlipping = true;
    return Commands.sequence(
        AutoBuilder.pathfindToPose(points[0], Constants.PATH_CONSTRAINTS, transitionVelocity),
        AutoBuilder.followPath(path));
  }
            </code></pre>

            <h4>Semi-Auto Uses</h4>
            <ul>
                <li>Drive to scoring position on button</li>
                <li>Auto-align to vision target then let driver finish</li>
                <li>Path-based assist modes</li>
            </ul>
        </section>

        <section>
            <h3>When to Use PathPlanner vs Handbuilt</h3>
            <h4>Use PathPlanner when:</h4>
            <ul>
                <li>You want quick, repeatable autos</li>
                <li>You don't want any possible interference</li>
				<li>You want to do the same thing, every time.</li>
            </ul>

            <h4>Create your own auto command sequence when:</h4>
            <ul>
                <li>You can sacrifice a tiny bit of consistency to be significantly more efficient</li>
                <li>You want your auto to move on to the next thing ASAP, not with pre-set wait times</li>
                <li>The game is too complex to create full paths for every scenario, and you could instead just define start/end positions</li>
            </ul>
        </section>

        <section>
            <h3>PathFinder</h3>
			<p>PathFinder is a sub-branch of pathplanner that allows the robot to drive to a set pose, while avoiding obstacles on the field.
			<code>AutoBuilder.pathfindToPose(...)</code>
			Use it when you want to autonomously get around field elements in teleop without much driver input.</p>

        </section>

        <!-- Page-specific content ends here -->
    </div>
</main>

<!-- Footer -->
<footer class="site-footer">
    <p>Team Resistance - Going against the current</p>
</footer>

<script>
    function toggleMobileMenu() {
        const sidebar = document.getElementById('sidebarNav');
        sidebar.classList.toggle('active');
    }

    document.addEventListener('click', function(event) {
        const sidebar = document.getElementById('sidebarNav');
        const toggle = document.querySelector('.mobile-menu-toggle');

        if (window.innerWidth <= 1024 &&
            !sidebar.contains(event.target) &&
            !toggle.contains(event.target) &&
            sidebar.classList.contains('active')) {
            sidebar.classList.remove('active');
        }
    });
</script>
</body>
</html>
